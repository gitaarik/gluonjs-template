(function(){"use strict";function a(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function b(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function c(a,c,d){return c&&b(a.prototype,c),d&&b(a,d),a}function d(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&f(a,b)}function e(a){return e=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},e(a)}function f(a,b){return f=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},f(a,b)}function g(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function h(a,b){return b&&("object"==typeof b||"function"==typeof b)?b:g(a)}function i(a,b){return b||(b=a.slice(0)),Object.freeze(Object.defineProperties(a,{raw:{value:Object.freeze(b)}}))}/**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */ // The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
/**
   * Finds the closing index of the last closed HTML tag.
   * This has 3 possible return values:
   *   - `-1`, meaning there is no tag in str.
   *   - `string.length`, meaning the last opened tag is unclosed.
   *   - Some positive number < str.length, meaning the index of the closing '>'.
   */function j(a){const b=a.lastIndexOf(">"),c=a.indexOf("<",b+1);return-1<c?a.length:b}/**
   * A placeholder for a dynamic expression in an HTML template.
   *
   * There are two built-in part types: AttributePart and NodePart. NodeParts
   * always represent a single dynamic expression, while AttributeParts may
   * represent as many expressions are contained in the attribute.
   *
   * A Template's parts are mutable, so parts can be replaced or modified
   * (possibly to implement different template semantics). The contract is that
   * parts can only be replaced, not removed, added or reordered, and parts must
   * always consume the correct number of values in their `update()` method.
   *
   * TODO(justinfagnani): That requirement is a little fragile. A
   * TemplateInstance could instead be more careful about which values it gives
   * to Part.update().
   */ /**
   * Removes the list of nodes from a Template safely. In addition to removing
   * nodes from the Template, the Template part indices are updated to match
   * the mutated Template DOM.
   *
   * As the template is walked the removal state is tracked and
   * part indices are adjusted as needed.
   *
   * div
   *   div#1 (remove) <-- start removing (removing node is div#1)
   *     div
   *       div#2 (remove)  <-- continue removing (removing node is still div#1)
   *         div
   * div <-- stop removing since previous sibling is the removing node (div#1, removed 4 nodes)
   */function k(a,b){const{element:{content:d},parts:c}=a,e=document.createTreeWalker(d,H,null,!1);let f=0,g=c[0],h=-1,i=0;const j=[];for(let d=null;e.nextNode();){h++;const a=e.currentNode;// End removal if stepped past the removing node
for(a.previousSibling===d&&(d=null),b.has(a)&&(j.push(a),null===d&&(d=a)),null!==d&&i++;g!==void 0&&g.index===h;)g.index=null===d?g.index-i:-1,g=c[++f]}j.forEach(a=>a.parentNode.removeChild(a))}/**
   * Inserts the given node into the Template, optionally before the given
   * refNode. In addition to inserting the node into the Template, the Template
   * part indices are updated to match the mutated Template DOM.
   */function l(a,b,c=null){const{element:{content:e},parts:d}=a;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===c||void 0===c)return void e.appendChild(b);const f=document.createTreeWalker(e,H,null,!1);let g=J(d),h=0,i=-1;for(;f.nextNode();){i++;const a=f.currentNode;for(a===c&&(c.parentNode.insertBefore(b,c),h=I(b));-1!==g&&d[g].index===i;){// If we've inserted the node, simply adjust all subsequent parts
if(0<h){for(;-1!==g;)d[g].index+=h,g=J(d,g);return}g=J(d,g)}}}/**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */ // Get a key to lookup in `templateCaches`.
/**
   * Removes all style elements from Templates for the given scopeName.
   */function m(a){M.forEach(b=>{const c=p.get(K(b,a));c!==void 0&&c.forEach(a=>{const{element:{content:b}}=a,c=b.querySelectorAll("style");k(a,new Set(Array.from(c)))})})}// NOTE: We're copying code from lit-html's `render` method here.
// We're doing this explicitly because the API for rendering templates is likely
// to change in the near term.
function n(a,b,c){const d=L(c),e=d(a);let f=b.__templateInstance;// Repeat render, just call update()
if(void 0!==f&&f.template===e&&f._partCallback===a.partCallback)return void f.update(a.values);// First render, create a new TemplateInstance and append it
f=new F(e,a.partCallback,d),b.__templateInstance=f;const g=f._clone();f.update(a.values);const h=b instanceof ShadowRoot?b.host:void 0;// If there's a shadow host, do ShadyCSS scoping...
h!==void 0&&"object"==typeof window.ShadyCSS&&(O(g,e,c),window.ShadyCSS.styleElement(h)),G(b,b.firstChild),b.appendChild(g)}/**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */ /**
   * Interprets a template literal as a lit-extended HTML template.
   */function o(){var a=i(["<div>GluonJS is working!</div>"]);return o=function(){return a},a}const p=new Map;/**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */class q{constructor(a,b,c,d=E){this.strings=a,this.values=b,this.type=c,this.partCallback=d}/**
       * Returns a string of HTML used to create a <template> element.
       */getHTML(){const a=this.strings.length-1;let b="",c=!0;for(let d=0;d<a;d++){const a=this.strings[d];b+=a;// We're in a text position if the previous string closed its tags.
// If it doesn't have any tags, then we use the previous text position
// state.
const e=j(a);c=-1<e?e<a.length:c,b+=c?t:r}return b+=this.strings[a],b}getTemplateElement(){const a=document.createElement("template");return a.innerHTML=this.getHTML(),a}}/**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */const r=`{{lit-${(Math.random()+"").slice(2)}}}`,t=`<!--${r}-->`,s=new RegExp(`${r}|${t}`),u=/[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;/**
   * An expression marker used text-positions, not attribute positions,
   * in template.
   */class v{constructor(a,b,c,d,e){this.type=a,this.index=b,this.name=c,this.rawName=d,this.strings=e}}const w=a=>-1!==a.index;/**
   * An updateable Template that tracks the location of dynamic parts.
   */class x{constructor(a,b){this.parts=[],this.element=b;const c=this.element.content,d=document.createTreeWalker(c,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                 NodeFilter.SHOW_TEXT */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
let e=-1,f=0;const g=[];// The actual previous node, accounting for removals: if a node is removed
// it will never be the previousNode.
let h,i;// Used to set previousNode at the top of the loop.
for(;d.nextNode();){e++,h=i;const b=i=d.currentNode;if(1===b.nodeType/* Node.ELEMENT_NODE */){if(!b.hasAttributes())continue;const c=b.attributes;// Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order. In
// particular, Edge/IE can return them out of order, so we cannot assume
// a correspondance between part index and attribute index.
let d=0;for(let a=0;a<c.length;a++)0<=c[a].value.indexOf(r)&&d++;for(;0<d--;){// Get the template literal section leading up to the first
// expression in this attribute
const d=a.strings[f],g=u.exec(d)[1],h=c.getNamedItem(g),i=h.value.split(s);// Find the attribute name
this.parts.push(new v("attribute",e,h.name,g,i)),b.removeAttribute(h.name),f+=i.length-1}}else if(3===b.nodeType/* Node.TEXT_NODE */){const a=b.nodeValue;if(0>a.indexOf(r))continue;const c=b.parentNode,d=a.split(s),h=d.length-1;f+=h;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let a=0;a<h;a++)c.insertBefore(""===d[a]?document.createComment(""):document.createTextNode(d[a]),b),this.parts.push(new v("node",e++));c.insertBefore(""===d[h]?document.createComment(""):document.createTextNode(d[h]),b),g.push(b)}else if(8===b.nodeType/* Node.COMMENT_NODE */&&b.nodeValue===r){const a=b.parentNode,c=b.previousSibling;// Add a new marker node to be the startNode of the Part if any of the
// following are true:
//  * We don't have a previousSibling
//  * previousSibling is being removed (thus it's not the
//    `previousNode`)
//  * previousSibling is not a Text node
//
// TODO(justinfagnani): We should be able to use the previousNode here
// as the marker node and reduce the number of extra nodes we add to a
// template. See https://github.com/PolymerLabs/lit-html/issues/147
null===c||c!==h||c.nodeType!==Node.TEXT_NODE?a.insertBefore(document.createComment(""),b):e--,this.parts.push(new v("node",e++)),g.push(b),null===b.nextSibling?a.insertBefore(document.createComment(""),b):e--,i=h,f++}}// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const c of g)c.parentNode.removeChild(c)}}/**
   * Returns a value ready to be inserted into a Part from a user-provided value.
   *
   * If the user value is a directive, this invokes the directive with the given
   * part. If the value is null, it's converted to undefined to work better
   * with certain DOM APIs, like textContent.
   */const y=(a,b)=>z(b)?(b=b(a),A):null===b?void 0:b,z=a=>"function"==typeof a&&!0===a.__litDirective,A={},B=a=>null===a||"object"!=typeof a&&"function"!=typeof a;class C{constructor(a,b,c,d){this.instance=a,this.element=b,this.name=c,this.strings=d,this.size=d.length-1,this._previousValues=[]}_interpolate(a,b){const c=this.strings,d=c.length-1;let e="";for(let f=0;f<d;f++){e+=c[f];const d=y(this,a[b+f]);if(d&&d!==A&&(Array.isArray(d)||"string"!=typeof d&&d[Symbol.iterator]))for(const a of d)// TODO: we need to recursively call getValue into iterables...
e+=a;else e+=d}return e+c[d]}_equalToPreviousValues(a,b){for(let c=b;c<b+this.size;c++)if(this._previousValues[c]!==a[c]||!B(a[c]))return!1;return!0}setValue(a,b){if(this._equalToPreviousValues(a,b))return;const c=this.strings;let d;2===c.length&&""===c[0]&&""===c[1]?(d=y(this,a[b]),Array.isArray(d)&&(d=d.join(""))):d=this._interpolate(a,b),d!==A&&this.element.setAttribute(this.name,d),this._previousValues=a}}class D{constructor(a,b,c){this.instance=a,this.startNode=b,this.endNode=c,this._previousValue=void 0}setValue(a){if(a=y(this,a),a!==A)if(B(a)){// Handle primitive values
// If the value didn't change, do nothing
if(a===this._previousValue)return;this._setText(a)}else a instanceof q?this._setTemplateResult(a):Array.isArray(a)||a[Symbol.iterator]?this._setIterable(a):a instanceof Node?this._setNode(a):void 0===a.then?this._setText(a):this._setPromise(a)}_insert(a){this.endNode.parentNode.insertBefore(a,this.endNode)}_setNode(a){this._previousValue===a||(this.clear(),this._insert(a),this._previousValue=a)}_setText(a){const b=this.startNode.nextSibling;a=a===void 0?"":a,b===this.endNode.previousSibling&&b.nodeType===Node.TEXT_NODE?b.textContent=a:this._setNode(document.createTextNode(a)),this._previousValue=a}_setTemplateResult(a){const b=this.instance._getTemplate(a);let c;this._previousValue&&this._previousValue.template===b?c=this._previousValue:(c=new F(b,this.instance._partCallback,this.instance._getTemplate),this._setNode(c._clone()),this._previousValue=c),c.update(a.values)}_setIterable(a){Array.isArray(this._previousValue)||(this.clear(),this._previousValue=[]);// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const b=this._previousValue;let c=0;for(const d of a){// Try to reuse an existing part
let a=b[c];// If no existing part, create a new one
if(a===void 0){// If we're creating the first item part, it's startNode should be the
// container's startNode
let d=this.startNode;// If we're not creating the first part, create a new separator marker
// node, and fix up the previous part's endNode to point to it
if(0<c){const a=b[c-1];d=a.endNode=document.createTextNode(""),this._insert(d)}a=new D(this.instance,d,this.endNode),b.push(a)}a.setValue(d),c++}if(0==c)this.clear(),this._previousValue=void 0;else if(c<b.length){const a=b[c-1];// Truncate the parts array so _previousValue reflects the current state
b.length=c,this.clear(a.endNode.previousSibling),a.endNode=this.endNode}}_setPromise(a){this._previousValue=a,a.then(b=>{this._previousValue===a&&this.setValue(b)})}clear(a=this.startNode){G(this.startNode.parentNode,a.nextSibling,this.endNode)}}const E=(a,b,c)=>{if("attribute"===b.type)return new C(a,c,b.name,b.strings);if("node"===b.type)return new D(a,c,c.nextSibling);throw new Error(`Unknown part type ${b.type}`)};/**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */class F{constructor(a,b,c){this._parts=[],this.template=a,this._partCallback=b,this._getTemplate=c}update(a){let b=0;for(const c of this._parts)c?void 0===c.size?(c.setValue(a[b]),b++):(c.setValue(a,b),b+=c.size):b++}_clone(){// Clone the node, rather than importing it, to keep the fragment in the
// template's document. This leaves the fragment inert so custom elements
// won't upgrade until after the main document adopts the node.
const a=this.template.element.content.cloneNode(!0),b=this.template.parts;if(0<b.length){// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const c=document.createTreeWalker(a,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                     NodeFilter.SHOW_TEXT */,null,!1);let d=-1;for(let a=0;a<b.length;a++){const e=b[a],f=w(e);// An inactive part has no coresponding Template node.
if(f)for(;d<e.index;)d++,c.nextNode();this._parts.push(f?this._partCallback(this,e,c.currentNode):void 0)}}return a}}/**
   * Removes nodes, starting from `startNode` (inclusive) to `endNode`
   * (exclusive), from `container`.
   */const G=(a,b,c=null)=>{for(let d=b;d!==c;){const b=d.nextSibling;a.removeChild(d),d=b}},H=NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,I=a=>{let b=1;for(const c=document.createTreeWalker(a,H,null,!1);c.nextNode();)b++;return b},J=(a,b=-1)=>{for(let c=b+1;c<a.length;c++){const b=a[c];if(w(b))return c}return-1},K=(a,b)=>`${a}--${b}`,L=a=>b=>{const c=K(b.type,a);let d=p.get(c);d===void 0&&(d=new Map,p.set(c,d));let e=d.get(b.strings);if(e===void 0){const c=b.getTemplateElement();"object"==typeof window.ShadyCSS&&window.ShadyCSS.prepareTemplateDom(c,a),e=new x(b,c),d.set(b.strings,e)}return e},M=["html","svg"],N=new Set,O=(a,b,c)=>{// only scope element template once per scope name
if(!N.has(c)){N.add(c);const d=document.createElement("template");// ApplyShim case
if(Array.from(a.querySelectorAll("style")).forEach(a=>{d.content.appendChild(a)}),window.ShadyCSS.prepareTemplateStyles(d,c),m(c),window.ShadyCSS.nativeShadow){const c=d.content.querySelector("style");null!==c&&(a.insertBefore(c,a.firstChild),l(b,c.cloneNode(!0),b.element.content.firstChild))}}},P=(a,...b)=>new q(a,b,"html",Q),Q=(a,b,c)=>{if("attribute"===b.type){if("on-"===b.rawName.substr(0,3)){const d=b.rawName.slice(3);return new T(a,c,d)}const d=b.name.substr(b.name.length-1);if("$"===d){const d=b.name.slice(0,-1);return new C(a,c,d,b.strings)}if("?"===d){const d=b.name.slice(0,-1);return new R(a,c,d,b.strings)}return new S(a,c,b.rawName,b.strings)}return E(a,b,c)};/**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */ /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */class R extends C{setValue(a,b){const c=this.strings;if(2===c.length&&""===c[0]&&""===c[1]){const c=y(this,a[b]);if(c===A)return;c?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)}else throw new Error("boolean attributes can only contain a single expression")}}class S extends C{setValue(a,b){const c=this.strings;let d;this._equalToPreviousValues(a,b)||(d=2===c.length&&""===c[0]&&""===c[1]?y(this,a[b]):this._interpolate(a,b),d!==A&&(this.element[this.name]=d),this._previousValues=a)}}class T{constructor(a,b,c){this.instance=a,this.element=b,this.eventName=c}setValue(a){const b=y(this,a);b===this._listener||(null==b?this.element.removeEventListener(this.eventName,this):null==this._listener&&this.element.addEventListener(this.eventName,this),this._listener=b)}handleEvent(a){"function"==typeof this._listener?this._listener.call(this.element,a):"function"==typeof this._listener.handleEvent&&this._listener.handleEvent(a)}}/**
   * @license
   * MIT License
   *
   * Copyright (c) 2017 Goffert van Gool
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */ // Key to store the HTML tag in a custom element class
const U=Symbol("tag"),V=Symbol("needsRender"),W=a=>a.replace(/([a-z](?=[A-Z]))|([A-Z](?=[A-Z][a-z]))/g,"$1$2-").toLowerCase(),X=a=>{a.$={},a.shadowRoot.querySelectorAll("[id]").forEach(b=>{a.$[b.id]=b})};// Key to store render status in a custom element instance
/**
   * A lightweight base class for custom elements
   *
   * Features:
   *
   *  - Determines an appropriate HTML tagname based on an element's class name
   *  - Efficient rendering engine using lit-html (https://github.com/Polymer/lit-html)
   *  - Creates a cache for descendant nodes with an `id` in the `$` property
   */class Y extends HTMLElement{/**
     * Returns the HTML tagname for elements of this class
     *
     * It defaults to the kebab-cased version of the class name. To override,
     * defined a `static get is()` property on your custom element class, and return
     * whatever string you want to use for the HTML tagname
     */static get is(){return this.hasOwnProperty(U)&&this[U]||(this[U]=W(this.name))}/**
     * Called when an element is connected to the DOM
     *
     * When an element has a `template`, attach a shadowRoot to the element,
     * and render the template. Once the template is rendered, creates an ID cache
     * in the `$` property
     *
     * When adding a `connectedCallback` to your custom element, you should call
     * `super.connectedCallback()` before doing anything other than actions
     * that alter the result of the template rendering.
     */connectedCallback(){"template"in this&&(this.attachShadow({mode:"open"}),this.render({sync:!0}),X(this))}/**
     * Renders the template for this element into the shadowRoot
     *
     * @param { sync }: perform a synchronous (blocking) render. The default render
     *     is asynchronous, and multiple calls to `render()` are batched by default
     *
     * @returns a Promise that resolves once template has been rendered
     */async render({sync:a=!1}={}){this[V]=!0,a||(await 0),this[V]&&(this[V]=!1,n(this.template,this.shadowRoot,this.constructor.is))}}var Z=/*#__PURE__*/function(b){function f(){return a(this,f),h(this,e(f).apply(this,arguments))}return d(f,b),c(f,[{key:"template",get:function(){return P(o())}}],[{key:"is",get:function(){return"gluonjs-template"}}]),f}(Y);customElements.define(Z.is,Z)})();
//# sourceMappingURL=gluonjs-template.es5.min.js.map
