(function(){"use strict";/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ // The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
/**
     * Finds the closing index of the last closed HTML tag.
     * This has 3 possible return values:
     *   - `-1`, meaning there is no tag in str.
     *   - `string.length`, meaning the last opened tag is unclosed.
     *   - Some positive number < str.length, meaning the index of the closing '>'.
     */function a(a){const b=a.lastIndexOf(">"),c=a.indexOf("<",b+1);return-1<c?a.length:b}/**
     * A placeholder for a dynamic expression in an HTML template.
     *
     * There are two built-in part types: AttributePart and NodePart. NodeParts
     * always represent a single dynamic expression, while AttributeParts may
     * represent as many expressions are contained in the attribute.
     *
     * A Template's parts are mutable, so parts can be replaced or modified
     * (possibly to implement different template semantics). The contract is that
     * parts can only be replaced, not removed, added or reordered, and parts must
     * always consume the correct number of values in their `update()` method.
     *
     * TODO(justinfagnani): That requirement is a little fragile. A
     * TemplateInstance could instead be more careful about which values it gives
     * to Part.update().
     */ /**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1, removed 4 nodes)
     */function b(a,b){const{element:{content:d},parts:c}=a,e=document.createTreeWalker(d,x,null,!1);let f=0,g=c[0],h=-1,i=0;const j=[];for(let d=null;e.nextNode();){h++;const a=e.currentNode;// End removal if stepped past the removing node
for(a.previousSibling===d&&(d=null),b.has(a)&&(j.push(a),null===d&&(d=a)),null!==d&&i++;g!==void 0&&g.index===h;)g.index=null===d?g.index-i:-1,g=c[++f]}j.forEach(a=>a.parentNode.removeChild(a))}/**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */function c(a,b,c=null){const{element:{content:e},parts:d}=a;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===c||void 0===c)return void e.appendChild(b);const f=document.createTreeWalker(e,x,null,!1);let g=z(d),h=0,i=-1;for(;f.nextNode();){i++;const a=f.currentNode;for(a===c&&(c.parentNode.insertBefore(b,c),h=y(b));-1!==g&&d[g].index===i;){// If we've inserted the node, simply adjust all subsequent parts
if(0<h){for(;-1!==g;)d[g].index+=h,g=z(d,g);return}g=z(d,g)}}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ // Get a key to lookup in `templateCaches`.
/**
     * Removes all style elements from Templates for the given scopeName.
     */function d(a){C.forEach(c=>{const d=f.get(A(c,a));d!==void 0&&d.forEach(a=>{const{element:{content:c}}=a,d=c.querySelectorAll("style");b(a,new Set(Array.from(d)))})})}// NOTE: We're copying code from lit-html's `render` method here.
// We're doing this explicitly because the API for rendering templates is likely
// to change in the near term.
function e(a,b,c){const d=B(c),e=d(a);let f=b.__templateInstance;// Repeat render, just call update()
if(void 0!==f&&f.template===e&&f._partCallback===a.partCallback)return void f.update(a.values);// First render, create a new TemplateInstance and append it
f=new v(e,a.partCallback,d),b.__templateInstance=f;const g=f._clone();f.update(a.values);const h=b instanceof ShadowRoot?b.host:void 0;// If there's a shadow host, do ShadyCSS scoping...
h!==void 0&&"object"==typeof window.ShadyCSS&&(E(g,e,c),window.ShadyCSS.styleElement(h)),w(b,b.firstChild),b.appendChild(g)}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * Interprets a template literal as a lit-extended HTML template.
     */const f=new Map;/**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */class g{constructor(a,b,c,d=u){this.strings=a,this.values=b,this.type=c,this.partCallback=d}/**
         * Returns a string of HTML used to create a <template> element.
         */getHTML(){const b=this.strings.length-1;let c="",d=!0;for(let e=0;e<b;e++){const b=this.strings[e];c+=b;// We're in a text position if the previous string closed its tags.
// If it doesn't have any tags, then we use the previous text position
// state.
const f=a(b);d=-1<f?f<b.length:d,c+=d?j:h}return c+=this.strings[b],c}getTemplateElement(){const a=document.createElement("template");return a.innerHTML=this.getHTML(),a}}/**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */const h=`{{lit-${(Math.random()+"").slice(2)}}}`,j=`<!--${h}-->`,i=new RegExp(`${h}|${j}`),k=/[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;/**
     * An expression marker used text-positions, not attribute positions,
     * in template.
     */class l{constructor(a,b,c,d,e){this.type=a,this.index=b,this.name=c,this.rawName=d,this.strings=e}}const m=a=>-1!==a.index;/**
     * An updateable Template that tracks the location of dynamic parts.
     */class n{constructor(a,b){this.parts=[],this.element=b;const c=this.element.content,d=document.createTreeWalker(c,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                   NodeFilter.SHOW_TEXT */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
let e=-1,f=0;const g=[];// The actual previous node, accounting for removals: if a node is removed
// it will never be the previousNode.
let j,m;// Used to set previousNode at the top of the loop.
for(;d.nextNode();){e++,j=m;const b=m=d.currentNode;if(1===b.nodeType/* Node.ELEMENT_NODE */){if(!b.hasAttributes())continue;const c=b.attributes;// Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order. In
// particular, Edge/IE can return them out of order, so we cannot assume
// a correspondance between part index and attribute index.
let d=0;for(let a=0;a<c.length;a++)0<=c[a].value.indexOf(h)&&d++;for(;0<d--;){// Get the template literal section leading up to the first
// expression in this attribute
const d=a.strings[f],g=k.exec(d)[1],h=c.getNamedItem(g),j=h.value.split(i);// Find the attribute name
this.parts.push(new l("attribute",e,h.name,g,j)),b.removeAttribute(h.name),f+=j.length-1}}else if(3===b.nodeType/* Node.TEXT_NODE */){const a=b.nodeValue;if(0>a.indexOf(h))continue;const c=b.parentNode,d=a.split(i),j=d.length-1;f+=j;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let a=0;a<j;a++)c.insertBefore(""===d[a]?document.createComment(""):document.createTextNode(d[a]),b),this.parts.push(new l("node",e++));c.insertBefore(""===d[j]?document.createComment(""):document.createTextNode(d[j]),b),g.push(b)}else if(8===b.nodeType/* Node.COMMENT_NODE */&&b.nodeValue===h){const a=b.parentNode,c=b.previousSibling;// Add a new marker node to be the startNode of the Part if any of the
// following are true:
//  * We don't have a previousSibling
//  * previousSibling is being removed (thus it's not the
//    `previousNode`)
//  * previousSibling is not a Text node
//
// TODO(justinfagnani): We should be able to use the previousNode here
// as the marker node and reduce the number of extra nodes we add to a
// template. See https://github.com/PolymerLabs/lit-html/issues/147
null===c||c!==j||c.nodeType!==Node.TEXT_NODE?a.insertBefore(document.createComment(""),b):e--,this.parts.push(new l("node",e++)),g.push(b),null===b.nextSibling?a.insertBefore(document.createComment(""),b):e--,m=j,f++}}// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const c of g)c.parentNode.removeChild(c)}}/**
     * Returns a value ready to be inserted into a Part from a user-provided value.
     *
     * If the user value is a directive, this invokes the directive with the given
     * part. If the value is null, it's converted to undefined to work better
     * with certain DOM APIs, like textContent.
     */const o=(a,b)=>p(b)?(b=b(a),q):null===b?void 0:b,p=a=>"function"==typeof a&&!0===a.__litDirective,q={},r=a=>null===a||"object"!=typeof a&&"function"!=typeof a;class s{constructor(a,b,c,d){this.instance=a,this.element=b,this.name=c,this.strings=d,this.size=d.length-1,this._previousValues=[]}_interpolate(a,b){const c=this.strings,d=c.length-1;let e="";for(let f=0;f<d;f++){e+=c[f];const d=o(this,a[b+f]);if(d&&d!==q&&(Array.isArray(d)||"string"!=typeof d&&d[Symbol.iterator]))for(const a of d)// TODO: we need to recursively call getValue into iterables...
e+=a;else e+=d}return e+c[d]}_equalToPreviousValues(a,b){for(let c=b;c<b+this.size;c++)if(this._previousValues[c]!==a[c]||!r(a[c]))return!1;return!0}setValue(a,b){if(this._equalToPreviousValues(a,b))return;const c=this.strings;let d;2===c.length&&""===c[0]&&""===c[1]?(d=o(this,a[b]),Array.isArray(d)&&(d=d.join(""))):d=this._interpolate(a,b),d!==q&&this.element.setAttribute(this.name,d),this._previousValues=a}}class t{constructor(a,b,c){this.instance=a,this.startNode=b,this.endNode=c,this._previousValue=void 0}setValue(a){if(a=o(this,a),a!==q)if(r(a)){// Handle primitive values
// If the value didn't change, do nothing
if(a===this._previousValue)return;this._setText(a)}else a instanceof g?this._setTemplateResult(a):Array.isArray(a)||a[Symbol.iterator]?this._setIterable(a):a instanceof Node?this._setNode(a):void 0===a.then?this._setText(a):this._setPromise(a)}_insert(a){this.endNode.parentNode.insertBefore(a,this.endNode)}_setNode(a){this._previousValue===a||(this.clear(),this._insert(a),this._previousValue=a)}_setText(a){const b=this.startNode.nextSibling;a=a===void 0?"":a,b===this.endNode.previousSibling&&b.nodeType===Node.TEXT_NODE?b.textContent=a:this._setNode(document.createTextNode(a)),this._previousValue=a}_setTemplateResult(a){const b=this.instance._getTemplate(a);let c;this._previousValue&&this._previousValue.template===b?c=this._previousValue:(c=new v(b,this.instance._partCallback,this.instance._getTemplate),this._setNode(c._clone()),this._previousValue=c),c.update(a.values)}_setIterable(a){Array.isArray(this._previousValue)||(this.clear(),this._previousValue=[]);// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const b=this._previousValue;let c=0;for(const d of a){// Try to reuse an existing part
let a=b[c];// If no existing part, create a new one
if(a===void 0){// If we're creating the first item part, it's startNode should be the
// container's startNode
let d=this.startNode;// If we're not creating the first part, create a new separator marker
// node, and fix up the previous part's endNode to point to it
if(0<c){const a=b[c-1];d=a.endNode=document.createTextNode(""),this._insert(d)}a=new t(this.instance,d,this.endNode),b.push(a)}a.setValue(d),c++}if(0==c)this.clear(),this._previousValue=void 0;else if(c<b.length){const a=b[c-1];// Truncate the parts array so _previousValue reflects the current state
b.length=c,this.clear(a.endNode.previousSibling),a.endNode=this.endNode}}_setPromise(a){this._previousValue=a,a.then(b=>{this._previousValue===a&&this.setValue(b)})}clear(a=this.startNode){w(this.startNode.parentNode,a.nextSibling,this.endNode)}}const u=(a,b,c)=>{if("attribute"===b.type)return new s(a,c,b.name,b.strings);if("node"===b.type)return new t(a,c,c.nextSibling);throw new Error(`Unknown part type ${b.type}`)};/**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */class v{constructor(a,b,c){this._parts=[],this.template=a,this._partCallback=b,this._getTemplate=c}update(a){let b=0;for(const c of this._parts)c?void 0===c.size?(c.setValue(a[b]),b++):(c.setValue(a,b),b+=c.size):b++}_clone(){// Clone the node, rather than importing it, to keep the fragment in the
// template's document. This leaves the fragment inert so custom elements
// won't upgrade until after the main document adopts the node.
const a=this.template.element.content.cloneNode(!0),b=this.template.parts;if(0<b.length){// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const c=document.createTreeWalker(a,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                       NodeFilter.SHOW_TEXT */,null,!1);let d=-1;for(let a=0;a<b.length;a++){const e=b[a],f=m(e);// An inactive part has no coresponding Template node.
if(f)for(;d<e.index;)d++,c.nextNode();this._parts.push(f?this._partCallback(this,e,c.currentNode):void 0)}}return a}}/**
     * Removes nodes, starting from `startNode` (inclusive) to `endNode`
     * (exclusive), from `container`.
     */const w=(a,b,c=null)=>{for(let d=b;d!==c;){const b=d.nextSibling;a.removeChild(d),d=b}},x=NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,y=a=>{let b=1;for(const c=document.createTreeWalker(a,x,null,!1);c.nextNode();)b++;return b},z=(a,b=-1)=>{for(let c=b+1;c<a.length;c++){const b=a[c];if(m(b))return c}return-1},A=(a,b)=>`${a}--${b}`,B=a=>b=>{const c=A(b.type,a);let d=f.get(c);d===void 0&&(d=new Map,f.set(c,d));let e=d.get(b.strings);if(e===void 0){const c=b.getTemplateElement();"object"==typeof window.ShadyCSS&&window.ShadyCSS.prepareTemplateDom(c,a),e=new n(b,c),d.set(b.strings,e)}return e},C=["html","svg"],D=new Set,E=(a,b,e)=>{// only scope element template once per scope name
if(!D.has(e)){D.add(e);const f=document.createElement("template");// ApplyShim case
if(Array.from(a.querySelectorAll("style")).forEach(a=>{f.content.appendChild(a)}),window.ShadyCSS.prepareTemplateStyles(f,e),d(e),window.ShadyCSS.nativeShadow){const d=f.content.querySelector("style");null!==d&&(a.insertBefore(d,a.firstChild),c(b,d.cloneNode(!0),b.element.content.firstChild))}}},F=(a,...b)=>new g(a,b,"html",G),G=(a,b,c)=>{if("attribute"===b.type){if("on-"===b.rawName.substr(0,3)){const d=b.rawName.slice(3);return new J(a,c,d)}const d=b.name.substr(b.name.length-1);if("$"===d){const d=b.name.slice(0,-1);return new s(a,c,d,b.strings)}if("?"===d){const d=b.name.slice(0,-1);return new H(a,c,d,b.strings)}return new I(a,c,b.rawName,b.strings)}return u(a,b,c)};/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */class H extends s{setValue(a,b){const c=this.strings;if(2===c.length&&""===c[0]&&""===c[1]){const c=o(this,a[b]);if(c===q)return;c?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)}else throw new Error("boolean attributes can only contain a single expression")}}class I extends s{setValue(a,b){const c=this.strings;let d;this._equalToPreviousValues(a,b)||(d=2===c.length&&""===c[0]&&""===c[1]?o(this,a[b]):this._interpolate(a,b),d!==q&&(this.element[this.name]=d),this._previousValues=a)}}class J{constructor(a,b,c){this.instance=a,this.element=b,this.eventName=c}setValue(a){const b=o(this,a);b===this._listener||(null==b?this.element.removeEventListener(this.eventName,this):null==this._listener&&this.element.addEventListener(this.eventName,this),this._listener=b)}handleEvent(a){"function"==typeof this._listener?this._listener.call(this.element,a):"function"==typeof this._listener.handleEvent&&this._listener.handleEvent(a)}}/**
     * @license
     * MIT License
     *
     * Copyright (c) 2017 Goffert van Gool
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */ // Key to store the HTML tag in a custom element class
const K=Symbol("tag"),L=Symbol("needsRender"),M=a=>a.replace(/([a-z](?=[A-Z]))|([A-Z](?=[A-Z][a-z]))/g,"$1$2-").toLowerCase(),N=a=>{a.$={},a.shadowRoot.querySelectorAll("[id]").forEach(b=>{a.$[b.id]=b})};// Key to store render status in a custom element instance
/**
     * A lightweight base class for custom elements
     *
     * Features:
     *
     *  - Determines an appropriate HTML tagname based on an element's class name
     *  - Efficient rendering engine using lit-html (https://github.com/Polymer/lit-html)
     *  - Creates a cache for descendant nodes with an `id` in the `$` property
     */class O extends HTMLElement{/**
       * Returns the HTML tagname for elements of this class
       *
       * It defaults to the kebab-cased version of the class name. To override,
       * defined a `static get is()` property on your custom element class, and return
       * whatever string you want to use for the HTML tagname
       */static get is(){return this.hasOwnProperty(K)&&this[K]||(this[K]=M(this.name))}/**
       * Called when an element is connected to the DOM
       *
       * When an element has a `template`, attach a shadowRoot to the element,
       * and render the template. Once the template is rendered, creates an ID cache
       * in the `$` property
       *
       * When adding a `connectedCallback` to your custom element, you should call
       * `super.connectedCallback()` before doing anything other than actions
       * that alter the result of the template rendering.
       */connectedCallback(){"template"in this&&(this.attachShadow({mode:"open"}),this.render({sync:!0}),N(this))}/**
       * Renders the template for this element into the shadowRoot
       *
       * @param { sync }: perform a synchronous (blocking) render. The default render
       *     is asynchronous, and multiple calls to `render()` are batched by default
       *
       * @returns a Promise that resolves once template has been rendered
       */async render({sync:a=!1}={}){this[L]=!0,a||(await 0),this[L]&&(this[L]=!1,e(this.template,this.shadowRoot,this.constructor.is))}}class P extends O{get template(){return F`<div>GluonJS is working!</div>`}static get is(){return"gluonjs-template"}}customElements.define(P.is,P)})();
//# sourceMappingURL=gluonjs-template.min.js.map
