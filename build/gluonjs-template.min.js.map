{"version":3,"file":"gluonjs-template.min.js","sources":["../node_modules/lit-html/lit-html.js","../node_modules/lit-html/lib/modify-template.js","../node_modules/lit-html/lib/shady-render.js","../node_modules/lit-html/lib/lit-extended.js","../node_modules/@gluon/gluon/gluon.js","../src/gluonjs-template.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nexport const templateCaches = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html');\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg');\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, partCallback = defaultPartCallback) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.partCallback = partCallback;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            // We're in a text position if the previous string closed its tags.\n            // If it doesn't have any tags, then we use the previous text position\n            // state.\n            const closing = findTagClose(s);\n            isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an <svg> tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the <svg> tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function defaultTemplateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param templateFactory a function to create a Template or retreive one from\n *     cache.\n */\nexport function render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template &&\n        instance._partCallback === result.partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance =\n        new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, not attribute positions,\n * in template.\n */\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n/**\n * Finds the closing index of the last closed HTML tag.\n * This has 3 possible return values:\n *   - `-1`, meaning there is no tag in str.\n *   - `string.length`, meaning the last opened tag is unclosed.\n *   - Some positive number < str.length, meaning the index of the closing '>'.\n */\nfunction findTagClose(str) {\n    const close = str.lastIndexOf('>');\n    const open = str.indexOf('<', close + 1);\n    return open > -1 ? str.length : close;\n}\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport const isTemplatePartActive = (part) => part.index !== -1;\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const content = this.element.content;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                // attributes are not guaranteed to be returned in document order. In\n                // particular, Edge/IE can return them out of order, so we cannot assume\n                // a correspondance between part index and attribute index.\n                let count = 0;\n                for (let i = 0; i < attributes.length; i++) {\n                    if (attributes[i].value.indexOf(marker) >= 0) {\n                        count++;\n                    }\n                }\n                while (count-- > 0) {\n                    // Get the template literal section leading up to the first\n                    // expression in this attribute\n                    const stringForPart = result.strings[partIndex];\n                    // Find the attribute name\n                    const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];\n                    // Find the corresponding attribute\n                    // TODO(justinfagnani): remove non-null assertion\n                    const attribute = attributes.getNamedItem(attributeNameInPart);\n                    const stringsForAttributeValue = attribute.value.split(markerRegex);\n                    this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));\n                    node.removeAttribute(attribute.name);\n                    partIndex += stringsForAttributeValue.length - 1;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                if (nodeValue.indexOf(marker) < 0) {\n                    continue;\n                }\n                const parent = node.parentNode;\n                const strings = nodeValue.split(markerRegex);\n                const lastIndex = strings.length - 1;\n                // We have a part for each match found\n                partIndex += lastIndex;\n                // Generate a new text node for each literal section\n                // These nodes are also used as the markers for node parts\n                for (let i = 0; i < lastIndex; i++) {\n                    parent.insertBefore((strings[i] === '')\n                        ? document.createComment('')\n                        : document.createTextNode(strings[i]), node);\n                    this.parts.push(new TemplatePart('node', index++));\n                }\n                parent.insertBefore(strings[lastIndex] === '' ?\n                    document.createComment('') :\n                    document.createTextNode(strings[lastIndex]), node);\n                nodesToRemove.push(node);\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === marker) {\n                const parent = node.parentNode;\n                // Add a new marker node to be the startNode of the Part if any of the\n                // following are true:\n                //  * We don't have a previousSibling\n                //  * previousSibling is being removed (thus it's not the\n                //    `previousNode`)\n                //  * previousSibling is not a Text node\n                //\n                // TODO(justinfagnani): We should be able to use the previousNode here\n                // as the marker node and reduce the number of extra nodes we add to a\n                // template. See https://github.com/PolymerLabs/lit-html/issues/147\n                const previousSibling = node.previousSibling;\n                if (previousSibling === null || previousSibling !== previousNode ||\n                    previousSibling.nodeType !== Node.TEXT_NODE) {\n                    parent.insertBefore(document.createComment(''), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a nextSibling add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a new marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(document.createComment(''), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\n/**\n * Returns a value ready to be inserted into a Part from a user-provided value.\n *\n * If the user value is a directive, this invokes the directive with the given\n * part. If the value is null, it's converted to undefined to work better\n * with certain DOM APIs, like textContent.\n */\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (isDirective(value)) {\n        value = value(part);\n        return noChange;\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nconst isDirective = (o) => typeof o === 'function' && o.__litDirective === true;\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n/**\n * @deprecated Use `noChange` instead.\n */\nexport { noChange as directiveValue };\nconst isPrimitiveValue = (value) => value === null ||\n    !(typeof value === 'object' || typeof value === 'function');\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n        this._previousValues = [];\n    }\n    _interpolate(values, startIndex) {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const v = getValue(this, values[startIndex + i]);\n            if (v && v !== noChange &&\n                (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                for (const t of v) {\n                    // TODO: we need to recursively call getValue into iterables...\n                    text += t;\n                }\n            }\n            else {\n                text += v;\n            }\n        }\n        return text + strings[l];\n    }\n    _equalToPreviousValues(values, startIndex) {\n        for (let i = startIndex; i < startIndex + this.size; i++) {\n            if (this._previousValues[i] !== values[i] ||\n                !isPrimitiveValue(values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    setValue(values, startIndex) {\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n            if (Array.isArray(value)) {\n                value = value.join('');\n            }\n        }\n        else {\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== noChange) {\n            this.element.setAttribute(this.name, value);\n        }\n        this._previousValues = values;\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitiveValue(value)) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        if (this._previousValue === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        value = value === undefined ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        const template = this.instance._getTemplate(value);\n        let instance;\n        if (this._previousValue && this._previousValue.template === template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        this._previousValue = value;\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback, getTemplate) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n        this._getTemplate = getTemplate;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (!part) {\n                valueIndex++;\n            }\n            else if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        // Clone the node, rather than importing it, to keep the fragment in the\n        // template's document. This leaves the fragment inert so custom elements\n        // won't upgrade until after the main document adopts the node.\n        const fragment = this.template.element.content.cloneNode(true);\n        const parts = this.template.parts;\n        if (parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                   NodeFilter.SHOW_TEXT */, null, false);\n            let index = -1;\n            for (let i = 0; i < parts.length; i++) {\n                const part = parts[i];\n                const partActive = isTemplatePartActive(part);\n                // An inactive part has no coresponding Template node.\n                if (partActive) {\n                    while (index < part.index) {\n                        index++;\n                        walker.nextNode();\n                    }\n                }\n                this._parts.push(partActive ? this._partCallback(this, part, walker.currentNode) : undefined);\n            }\n        }\n        return fragment;\n    }\n}\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isTemplatePartActive } from '../lit-html.js';\nconst walkerNodeFilter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n    NodeFilter.SHOW_TEXT;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1, removed 4 nodes)\n */\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = 0;\n    let part = parts[0];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we're removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            part = parts[++partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there's no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            refNode.parentNode.insertBefore(node, refNode);\n            insertCount = countNodes(node);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we've inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { removeNodes, Template, templateCaches, TemplateInstance } from '../lit-html.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (typeof window.ShadyCSS === 'object') {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.set(result.strings, template);\n    }\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nfunction removeStylesFromLitTemplates(scopeName) {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.forEach((template) => {\n                const { element: { content } } = template;\n                const styles = content.querySelectorAll('style');\n                removeNodesFromTemplate(template, new Set(Array.from(styles)));\n            });\n        }\n    });\n}\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered output.\n */\nconst ensureStylesScoped = (fragment, template, scopeName) => {\n    // only scope element template once per scope name\n    if (!shadyRenderSet.has(scopeName)) {\n        shadyRenderSet.add(scopeName);\n        const styleTemplate = document.createElement('template');\n        Array.from(fragment.querySelectorAll('style')).forEach((s) => {\n            styleTemplate.content.appendChild(s);\n        });\n        window.ShadyCSS.prepareTemplateStyles(styleTemplate, scopeName);\n        // Fix templates: note the expectation here is that the given `fragment`\n        // has been generated from the given `template` which contains\n        // the set of templates rendered into this scope.\n        // It is only from this set of initial templates from which styles\n        // will be scoped and removed.\n        removeStylesFromLitTemplates(scopeName);\n        // ApplyShim case\n        if (window.ShadyCSS.nativeShadow) {\n            const style = styleTemplate.content.querySelector('style');\n            if (style !== null) {\n                // Insert style into rendered fragment\n                fragment.insertBefore(style, fragment.firstChild);\n                // Insert into lit-template (for subsequent renders)\n                insertNodeIntoTemplate(template, style.cloneNode(true), template.element.content.firstChild);\n            }\n        }\n    }\n};\n// NOTE: We're copying code from lit-html's `render` method here.\n// We're doing this explicitly because the API for rendering templates is likely\n// to change in the near term.\nexport function render(result, container, scopeName) {\n    const templateFactory = shadyTemplateFactory(scopeName);\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template &&\n        instance._partCallback === result.partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance =\n        new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    const host = container instanceof ShadowRoot ?\n        container.host :\n        undefined;\n    // If there's a shadow host, do ShadyCSS scoping...\n    if (host !== undefined && typeof window.ShadyCSS === 'object') {\n        ensureStylesScoped(fragment, template, scopeName);\n        window.ShadyCSS.styleElement(host);\n    }\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n}\n//# sourceMappingURL=shady-render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, defaultPartCallback, noChange, getValue, SVGTemplateResult, TemplateResult } from '../lit-html.js';\nexport { render } from '../lit-html.js';\n/**\n * Interprets a template literal as a lit-extended HTML template.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', extendedPartCallback);\n/**\n * Interprets a template literal as a lit-extended SVG template.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', extendedPartCallback);\n/**\n * A PartCallback which allows templates to set properties and declarative\n * event handlers.\n *\n * Properties are set by default, instead of attributes. Attribute names in\n * lit-html templates preserve case, so properties are case sensitive. If an\n * expression takes up an entire attribute value, then the property is set to\n * that value. If an expression is interpolated with a string or other\n * expressions then the property is set to the string result of the\n * interpolation.\n *\n * To set an attribute instead of a property, append a `$` suffix to the\n * attribute name.\n *\n * Example:\n *\n *     html`<button class$=\"primary\">Buy Now</button>`\n *\n * To set an event handler, prefix the attribute name with `on-`:\n *\n * Example:\n *\n *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n *\n */\nexport const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        if (templatePart.rawName.substr(0, 3) === 'on-') {\n            const eventName = templatePart.rawName.slice(3);\n            return new EventPart(instance, node, eventName);\n        }\n        const lastChar = templatePart.name.substr(templatePart.name.length - 1);\n        if (lastChar === '$') {\n            const name = templatePart.name.slice(0, -1);\n            return new AttributePart(instance, node, name, templatePart.strings);\n        }\n        if (lastChar === '?') {\n            const name = templatePart.name.slice(0, -1);\n            return new BooleanAttributePart(instance, node, name, templatePart.strings);\n        }\n        return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n};\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            const value = getValue(this, values[startIndex]);\n            if (value === noChange) {\n                return;\n            }\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        else {\n            throw new Error('boolean attributes can only contain a single expression');\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        let value;\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n        }\n        else {\n            // Interpolation, so interpolate\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== noChange) {\n            this.element[this.name] = value;\n        }\n        this._previousValues = values;\n    }\n}\nexport class EventPart {\n    constructor(instance, element, eventName) {\n        this.instance = instance;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        const listener = getValue(this, value);\n        if (listener === this._listener) {\n            return;\n        }\n        if (listener == null) {\n            this.element.removeEventListener(this.eventName, this);\n        }\n        else if (this._listener == null) {\n            this.element.addEventListener(this.eventName, this);\n        }\n        this._listener = listener;\n    }\n    handleEvent(event) {\n        if (typeof this._listener === 'function') {\n            this._listener.call(this.element, event);\n        }\n        else if (typeof this._listener.handleEvent === 'function') {\n            this._listener.handleEvent(event);\n        }\n    }\n}\n//# sourceMappingURL=lit-extended.js.map","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2017 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { render } from '../../lit-html/lib/shady-render.js';\nexport { html } from '../../lit-html/lib/lit-extended.js';\n\n// Key to store the HTML tag in a custom element class\nconst TAG = Symbol('tag');\n\n// Key to store render status in a custom element instance\nconst NEEDSRENDER = Symbol('needsRender');\n\n// Transforms a camelCased string into a kebab-cased string\nconst camelToKebab = camel => camel.replace(/([a-z](?=[A-Z]))|([A-Z](?=[A-Z][a-z]))/g, '$1$2-').toLowerCase();\n\n// Creates an ID cache in the `$` property of a custom element instance\nconst createIdCache = element => {\n  element.$ = {};\n  element.shadowRoot.querySelectorAll('[id]').forEach(node => {\n    element.$[node.id] = node;\n  });\n};\n\n/**\n * A lightweight base class for custom elements\n *\n * Features:\n *\n *  - Determines an appropriate HTML tagname based on an element's class name\n *  - Efficient rendering engine using lit-html (https://github.com/Polymer/lit-html)\n *  - Creates a cache for descendant nodes with an `id` in the `$` property\n */\nexport class GluonElement extends HTMLElement {\n  /**\n   * Returns the HTML tagname for elements of this class\n   *\n   * It defaults to the kebab-cased version of the class name. To override,\n   * defined a `static get is()` property on your custom element class, and return\n   * whatever string you want to use for the HTML tagname\n   */\n  static get is() {\n    return (this.hasOwnProperty(TAG) && this[TAG]) || (this[TAG] = camelToKebab(this.name));\n  }\n\n  /**\n   * Called when an element is connected to the DOM\n   *\n   * When an element has a `template`, attach a shadowRoot to the element,\n   * and render the template. Once the template is rendered, creates an ID cache\n   * in the `$` property\n   *\n   * When adding a `connectedCallback` to your custom element, you should call\n   * `super.connectedCallback()` before doing anything other than actions\n   * that alter the result of the template rendering.\n   */\n  connectedCallback() {\n    if ('template' in this) {\n      this.attachShadow({ mode: 'open' });\n      this.render({ sync: true });\n      createIdCache(this);\n    }\n  }\n\n  /**\n   * Renders the template for this element into the shadowRoot\n   *\n   * @param { sync }: perform a synchronous (blocking) render. The default render\n   *     is asynchronous, and multiple calls to `render()` are batched by default\n   *\n   * @returns a Promise that resolves once template has been rendered\n   */\n  async render({ sync = false } = {}) {\n    this[NEEDSRENDER] = true;\n    if (!sync) {\n      await 0;\n    }\n    if (this[NEEDSRENDER]) {\n      this[NEEDSRENDER] = false;\n      render(this.template, this.shadowRoot, this.constructor.is);\n    }\n  }\n}\n","import { GluonElement, html } from '@gluon/gluon/gluon.js';\n\nclass GluonjsTemplate extends GluonElement {\n  get template() {\n    return html`<div>GluonJS is working!</div>`;\n  }\n  static get is() {\n    return 'gluonjs-template';\n  }\n}\n\ncustomElements.define(GluonjsTemplate.is, GluonjsTemplate);\n"],"names":["findTagClose","str","close","lastIndexOf","open","indexOf","length","removeNodesFromTemplate","template","nodesToRemove","element","content","parts","walker","document","createTreeWalker","walkerNodeFilter","partIndex","part","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","nextNode","node","currentNode","previousSibling","has","push","index","forEach","n","parentNode","removeChild","insertNodeIntoTemplate","refNode","appendChild","nextActiveIndexInTemplateParts","insertCount","walkerIndex","walkerNode","insertBefore","countNodes","removeStylesFromLitTemplates","scopeName","TEMPLATE_TYPES","type","templates","templateCaches","get","getTemplateCacheKey","styles","querySelectorAll","Set","Array","from","render","result","container","templateFactory","shadyTemplateFactory","instance","__templateInstance","_partCallback","partCallback","update","values","TemplateInstance","fragment","_clone","host","ShadowRoot","window","ShadyCSS","ensureStylesScoped","styleElement","removeNodes","firstChild","Map","TemplateResult","constructor","strings","defaultPartCallback","getHTML","l","html","isTextBinding","i","s","closing","nodeMarker","marker","getTemplateElement","createElement","innerHTML","Math","random","slice","markerRegex","RegExp","lastAttributeNameRegex","TemplatePart","name","rawName","isTemplatePartActive","Template","previousNode","nodeType","hasAttributes","attributes","count","value","stringForPart","attributeNameInPart","exec","attribute","getNamedItem","stringsForAttributeValue","split","removeAttribute","nodeValue","parent","lastIndex","createComment","createTextNode","Node","TEXT_NODE","nextSibling","getValue","isDirective","noChange","o","__litDirective","isPrimitiveValue","AttributePart","size","_previousValues","_interpolate","startIndex","text","v","isArray","Symbol","iterator","t","_equalToPreviousValues","setValue","join","setAttribute","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","_setNode","then","_setPromise","_insert","clear","textContent","_getTemplate","itemParts","item","itemPart","itemStart","previousPart","lastPart","templatePart","Error","getTemplate","_parts","valueIndex","cloneNode","partActive","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","cacheKey","templateCache","set","prepareTemplateDom","shadyRenderSet","add","styleTemplate","prepareTemplateStyles","nativeShadow","style","querySelector","extendedPartCallback","substr","eventName","EventPart","lastChar","BooleanAttributePart","PropertyPart","listener","_listener","removeEventListener","addEventListener","handleEvent","event","call","TAG","NEEDSRENDER","camelToKebab","camel","replace","toLowerCase","createIdCache","$","shadowRoot","id","GluonElement","HTMLElement","is","hasOwnProperty","connectedCallback","attachShadow","mode","sync","GluonjsTemplate","customElements","define"],"mappings":"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"}